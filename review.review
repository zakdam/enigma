0) я обновил coding style на systemverilog в twiki, посмотрите его)

По модулю enigma_1:

+ 1) убрать закомментарованный код
+ 2) объявление модуля должно выглядеть таким образом:

  input  logic       clk_i,               //synchrosignal
  input  logic       rst_i,               //asynchronous reset

  input  logic [6:0] in_symb_i,           //incoming NOT CODED letter, each letter is coded by its serial number
  input  logic       in_symb_val_i,       //incoming symbol is valid

  input  logic       rrs_rst_i,           //only rotors reset

  output logic [6:0] out_symb_o,          //outcoming CODED letter, each letter is coded by its serial number
  output logic       out_symb__val_o      //outcoming encoded symbols are valid

   У нас есть такое правило: есть входные и выходные данные и есть их
   валидность, название которой формируется добавлением val к данным.
   Так же важно сигналы не перемешивать и те сигналы, которые логические связаны
   размещать рядом, и такие группы отделять пустой строчкой.

+ 3) не очень мне было очевидно, что rrs это rotors reset.
   Почему бы сигнал не назвать rotors_rst_i

+ 4) Задержанные сигналы должны имеют постфикс _d.
   Я бы сделал так:
   logic      [6:0] r1;
   logic [5:1][6:0] r1_d;

+ 5) Формирование задержанных сигналов должно быть в отдельном блоке.
   Не надо это смешивать.

6) Квартус может не собрать проект, т.к. будет ругаться на вот эту конструкцию:
     always_ff @( posedge clk_i or negedge rst_i or negedge rrs_rst_i )
   У триггера нет двух входов для асинхронного сброса, и так писать не рекомендуется.
   Думаю ( я почти уверен ), что правильно сделать так, чтобы сброс роторов был синхронным.

+ 7) rst_i у нас по умолчанию переход с 0 в 1, то есть nededge rst_i поменяй, пожалуйста,
   на posedge rst_i и убери отрицание.

8) out_symb_o расчитывается комбинационкой и уходит на выход, но зачем-то пересохраняется
   в result[6]. Лучше всё-таки out_symb_o взять с result[6] и encod_val_o тоже взять из шестерки.

+ 9) Назначения en_val_i_d[5:1] сделать циклом.

+ 10) После module enigma_1 не должно быть пустой строчки.

+ 11) Объявления "переменных" не должны иметь отступ в два пробела, например
//in-logic of ALL blocks (dominoes principal)
  logic [5:0][6:0]   r1_s;                //0 - non-delayed, 1 - delayed for one stroke,...
  logic [4:0][6:0]   r2_s;                //same numeration
  logic [3:0][6:0]   r3_s;                //same numeration

+ 12) Конструкцию else-if мы пишем вот так:

    if( !rst_i )
      r1_s[0] <= R1_PAR;
    else 
      if( !rrs_rst_i )
        r1_s[0] <= R1_PAR;
      else 
        if( r1_s[0] == 26 )
          r1_s[0] <= 1;
        else 
          if( en_val_i == 1'b1 ) 
            r1_s[0] <= r1_s[0] + 1;

    Обращаю внимание, что после if нет пробела.

+ 13) Зачем писать if( en_val_i == 1'b1 ), когда можно простро if( en_val_i )?

+ 14) Когда добавляешь/назначаешь какие-то числа, то по возможности, указывай её размерность.
    К примеру:
      r1_s[0] <= r1_s[0] + 6'd1;
    Иначе будут предупреждения в квартусе, если не ошибаюсь) 
    Предупреждения не ошибки, конечно, но их много не желательно иметь.

+ 15) При описании комментария ставь после "//" пробел, то есть:
//rotor 3 straight movement -> // rotor 3 straight movement
    Это во всех файлах, разумеется. Какие и другие пункты, которые к кодинг стайлу и какой-то
    идеалогии относятся.

16) Все три ротора выполняют одинаковые операции, но с разными данными.
    Однако, похожий код дублируется. Сократить дублирование выносом логики одного ротора 
    в отдельную сущность (модуль).

+ 17) str_r1_array, back_r1_array и прочие лучше переименовать вот так:
    array_str_r1, array_back_r1. Либо наоборот: r1_str_array, r1_back_array. 
    Мне даже второй вариант больше нравится.
    
    Небольшая иерархичность появляется, но может это я слишком придираюсь.

+ 18) Было бы неплохо число 26 в отдельный параметр (localparam) выделить,
    чтобы никто не догадывался, что это количество букв в алфавите латинском.
    Понятно, что это число никогда не изменится, однако читаемость, скорее всего
    улучшится, да и в книгах рекомендуют)

+ 19) R1/R2/R3_PAR - если PAR - это параметр, то это лишнее обозначение:
    любой прыгнет и увидит, что это параметр)
    Лучше название типа R1_INIT_VALUE или INIT_VALUE_R1
    

project_tb:

+ 20) 
   Строчка 55:
   #2010;
   Это неправильно и некрасиво, несмотря на то, что потом @posedge(clk_i).
   Если надо отсчитать нужное количество клоков, используете конструкцию repeat.

+ 21) 
  Строчка 75:
  Зачем обнулять symbol_i?

+ 22) В блоках initial лучше при назначении сигнала использовать <= присваивание,
    причем для всех случаях кроме начального инициализационного значения.
    Должно быть вот так:
    initial
      begin
        a = '0;

        @( posedge clk_i );
        a <= 'd5;
        
        @( posedge clk_i );
        @( posedge clk_i );
        a <= 'd7;
        
        @( posedge clk_i );
        a <= 'd15;
      end

    Обрати внимание на разделения пробелами.

+ 23) Нельзя использовать _i/_o для названий сигналов, если они не являются входами/выходами
    модуля, грубо говоря так:

enigma_top et(
  .clk_i        ( clk       ),
  .rst_i        ( rst       ),
  .symb_val_i   ( symb_val  ),
  .rrs_rst_i    ( rrs_rst   ),
  .symb_numb_i  ( symb_numb ),
  .symbol_i     ( symbol    ),

  .symb_val_o   ( symb_val  ),
  .symbol_o     ( symbol    )
);

24) Строчка 88:
    Переделать так, чтобы никакого #10 не было. Только @( posedge clk_i );

enigma_top:

+ 25) Переменные trans не несут никакой информативной составляющей.
    Переименовать.

wrapper:

26) Почему im_wr_ad, om_wr_ad 64-битные?

         рандом, они сделаны с запасом

+ 27) Если назвали память im_mem, то все сигналы, которые к ней относятся должны иметь 
    префикс im_mem_, а не im_. Аналогично с out_mem.

28) Выделить блоки памяти в отдельный модуль, как вы делаете в блумовских фильтрах.
    Это, к примеру, позволит избежать следующей ошибки:

    always_ff @( posedge clk_i or negedge rst_i )
      begin
        if ( om_wr_en )
          begin
            out_mem[om_wr_ad] <= out_en_i;                            
          end
      end

    а) Из-за копипасты, судя по всему пропущена строчка if( rst_i )
    б) Блоки памяти нельзя сбрасывать по rst_i.

+ 29) ad переименовать в addr. (см. coding style в twiki ).
    wrg в err/error.

+ 30) en_val_i_d[0] не должен показывать задержанный на такт en_val_i.
    Это должно хранится в переменной en_val_i_d[1].
    Также тут, мне кажется вы забыли begin/end и должно быть вот так:

    always_ff @( posedge clk_i or negedge rst_i )
      begin
        if ( !rst_i )
          encod_val_i_d <= 0;
        else
          begin
            encod_val_i_d[0] <= encod_val_i;
            encod_val_i_d[1] <= encod_val_i_d[0];
          end
      end

    И вообще переменная должна быть без _i, то есть en_val_d.

+ 31) Не очень понятно, зачем входы описывать logic для всех модулей...

      input  logic              clk_i,
      input  logic              rst_i,
      input  logic              symb_val_i,

    Должно работать и без этого.
    На некоторых выходах, действительно, без этого не обойтись.
